# Luc.Util

A high-performance .NET library for working with UUIDs. Provides fast, zero-allocation helpers for UUIDv4 (random) and UUIDv7 (time-ordered) formats — plus compact string encodings and conversion helpers.

## Features

- **UUID**: Core UUID struct with multiple encoding formats (hex, base36, base35, base32, base31)
- **UUIDv4**: Random UUID generation (RFC 4122)
- **UUIDv7**: Time-ordered UUID generation (RFC 9562)
- **Zero-allocation**: Stack-allocated operations for optimal performance
- **Multiple encodings**: Standard hex, base36 (25 chars), base35 (25 chars), base32 (26 chars), and base31 (26 chars)
- **Interop**: Extension methods for `System.Guid` conversion

## Usage

### Creating UUIDs

```csharp
using Luc.Util;

// Create a random UUIDv4
var uuid4 = UUID.NewV4();

// Create a time-ordered UUIDv7
var uuid7 = UUID.NewV7();

// Create UUIDv7 with custom timestamp and randomness
// Create UUIDv7 with a custom timestamp, random bytes, and sequence
// unixEpochMs is milliseconds since unix epoch
// randomBytes must be at least 8 bytes, seqBytes must be at least 2 bytes
var customUuid7 = UUID.NewV7(
    unixEpochMs: DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
    randomBytes: myRandomBytes,
    seqBytes: mySequenceBytes
);
```

### Working with UUIDs

```csharp
// Get the timestamp from UUIDv7
DateTimeOffset timestamp = uuid7.V7GetTimestamp();

// Convert to different formats
string hex = uuid7.ToString();           // Standard hyphenated format (36 chars incl hyphens)
string base64 = Base64.Encode(uuid7);        // 22-character Base64 (URL-safe, no padding) — not the Medo Id22 Base58
string base36 = Base36.Encode(uuid7, 25);        // 25-character base36 (0-9a-z)
string base35 = Base35.Encode(uuid7, 25);        // 25-character base35 (0-9a-z excluding l)
string base32 = Base32.Encode(uuid7, 26);        // 26-character base32 (same alphabet as Medo Id26; different algorithm)
string base31 = Base31.Encode(uuid7, 26);        // 26-character base31 (2-9, a-z excluding i, l, o)

// Access raw bytes
ReadOnlySpan<byte> bytes = uuid7.Bytes;

// Convert from System.Guid to Luc.Util.UUID
Guid systemGuid = Guid.NewGuid();
UUID baseUuid = systemGuid.AsUUID();
```

### Converting from System.Guid

```csharp
Guid systemGuid = Guid.NewGuid();

// Try to convert to UUIDv4
// Use `AsUUID` to convert from `System.Guid` to `Luc.Util.UUID` and then
// call `GetVersion()` or `GetVariant()` to inspect the value
UUID converted = systemGuid.AsUUID();
Console.WriteLine(converted.GetVersion());
```

### Parsing from Strings

```csharp
// Parse from base36 (25 char)
var uuidFrom36 = Base36.Decode<UUID>("00000000000000000000abcde", 25);

// Parse from base35 (25 char)
var uuidFrom35 = Base35.Decode<UUID>("00000000000000000000abcde", 25);

// Parse from base32 (26 char)
var uuidFrom32 = Base32.Decode<UUID>("00000000000000000000000000", 26);

// Parse from base31 (26 char)
var uuidFrom31 = Base31.Decode<UUID>("22222222222222222222222222", 26);
```

## Performance

All UUID operations are designed for zero-allocation performance:

## License

This project is licensed under the terms of the MIT License. See [../LICENSE.md](../LICENSE.md) for details.

---

## Tests and Test Data

- Unit tests are in `Luc.Util.Tests`. Run them with `dotnet test` at the solution root.
- UUIDv7 sample data is generated by `Luc.Util.Tests.SampleGenerator` and stored in `Luc.Util.Tests/Generated/Uuid7TestSamples.cs`.

To regenerate test samples run from the solution root:

```bash
dotnet run --project Luc.Util.Tests.SampleGenerator/Luc.Util.Tests.SampleGenerator.csproj
```

Run unit tests:

```bash
dotnet test
```

---

## Notes

- `Base36.Encode()` returns a 25-character string (when using the 25 fixed length); `Base36.Decode<UUID>()` requires exactly 25 characters.
- `Base35.Encode()` returns a 25-character string (output matches Medo Id25); `Base35.Decode<UUID>()` requires exactly 25 characters.
- `Base64.Encode()` returns a 22-character URL-safe Base64 string (no padding); `Base64.Decode<UUID>()` requires exactly 22 characters. Medo's `Id22` is Base58 (not compatible).
- `Base32.Encode()` returns a 26-character string using the same alphabet as Medo Id26 but a different encoding (not compatible with Medo Id26 values); `Base32.Decode<UUID>()` requires exactly 26 characters produced by `Base32.Encode()`.
- `Base31.Encode()` returns a 26-character string; `Base31.Decode<UUID>()` requires exactly 26 characters.
- `V7GetTimestamp()` extracts the 48-bit timestamp from UUIDv7 and returns a `DateTimeOffset`.
- For secure randomness, supply your own RNG when generating values in production.

### Medo Compatibility Summary

| Encoding | Length | Alphabet Relation            | Algorithm Match | Compatible with Medo |
|----------|--------|------------------------------|-----------------|----------------------|
| Base35   | 25     | Identical to Id25 (no 'l')   | Yes             | Yes (Id25)           |
| Base32   | 26     | Same alphabet as Id26        | No              | No                   |
| Base64   | 22     | Different (Medo uses Base58) | No              | No                   |
| Base31   | 26     | Different                    | N/A             | No                   |
| Base36   | 25     | Different                    | N/A             | No                   |
